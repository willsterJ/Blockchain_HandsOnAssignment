// Code generated by cmd/cgo; DO NOT EDIT.

//line /opt/gopath/src/github.com/hyperledger/fabric-ca/vendor/github.com/mattn/go-sqlite3/callback.go:1:1
// Copyright (C) 2019 Yasuhiro Matsumoto <mattn.jp@gmail.com>.
//
// Use of this source code is governed by an MIT-style
// license that can be found in the LICENSE file.

package sqlite3; import _cgo_unsafe "unsafe"

// You can't export a Go function to C and have definitions in the C
// preamble in the same file, so we have to have callbackTrampoline in
// its own file. Because we need a separate file anyway, the support
// code for SQLite custom functions is in here.

/*
#ifndef USE_LIBSQLITE3
#include <sqlite3-binding.h>
#else
#include <sqlite3.h>
#endif
#include <stdlib.h>

void _sqlite3_result_text(sqlite3_context* ctx, const char* s);
void _sqlite3_result_blob(sqlite3_context* ctx, const void* b, int l);
*/
import _ "unsafe"

import (
	"errors"
	"fmt"
	"math"
	"reflect"
	"sync"
	"unsafe"
)

//export callbackTrampoline
func callbackTrampoline(ctx * /*line :36:30*/_Ctype_struct_sqlite3_context /*line :36:47*/, argc int, argv ** /*line :36:66*/_Ctype_struct_sqlite3_value /*line :36:81*/) {
	args := (*[(math.MaxInt32 - 1) / unsafe.Sizeof((* /*line :37:51*/_Ctype_struct_sqlite3_value /*line :37:66*/)(nil))]* /*line :37:75*/_Ctype_struct_sqlite3_value /*line :37:90*/)(unsafe.Pointer(argv))[:argc:argc]
	fi := lookupHandle(uintptr(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :38:49*/ctx; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_user_data(_cgo0); }())).(*functionInfo)
	fi.Call(ctx, args)
}

//export stepTrampoline
func stepTrampoline(ctx * /*line :43:26*/_Ctype_struct_sqlite3_context /*line :43:43*/, argc  /*line :43:50*/_Ctype_int /*line :43:55*/, argv ** /*line :43:64*/_Ctype_struct_sqlite3_value /*line :43:79*/) {
	args := (*[(math.MaxInt32 - 1) / unsafe.Sizeof((* /*line :44:51*/_Ctype_struct_sqlite3_value /*line :44:66*/)(nil))]* /*line :44:75*/_Ctype_struct_sqlite3_value /*line :44:90*/)(unsafe.Pointer(argv))[:int(argc):int(argc)]
	ai := lookupHandle(uintptr(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :45:49*/ctx; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_user_data(_cgo0); }())).(*aggInfo)
	ai.Step(ctx, args)
}

//export doneTrampoline
func doneTrampoline(ctx * /*line :50:26*/_Ctype_struct_sqlite3_context /*line :50:43*/) {
	handle := uintptr(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :51:40*/ctx; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_user_data(_cgo0); }())
	ai := lookupHandle(handle).(*aggInfo)
	ai.Done(ctx)
}

//export compareTrampoline
func compareTrampoline(handlePtr uintptr, la  /*line :57:46*/_Ctype_int /*line :57:51*/, a * /*line :57:56*/_Ctype_char /*line :57:62*/, lb  /*line :57:67*/_Ctype_int /*line :57:72*/, b * /*line :57:77*/_Ctype_char /*line :57:83*/)  /*line :57:85*/_Ctype_int /*line :57:90*/ {
	cmp := lookupHandle(handlePtr).(func(string, string) int)
	return  /*line :59:9*/_Ctype_int /*line :59:14*/(cmp(( /*line :59:19*/_Cfunc_GoStringN /*line :59:29*/)(a, la), ( /*line :59:39*/_Cfunc_GoStringN /*line :59:49*/)(b, lb)))
}

//export commitHookTrampoline
func commitHookTrampoline(handle uintptr) int {
	callback := lookupHandle(handle).(func() int)
	return callback()
}

//export rollbackHookTrampoline
func rollbackHookTrampoline(handle uintptr) {
	callback := lookupHandle(handle).(func())
	callback()
}

//export updateHookTrampoline
func updateHookTrampoline(handle uintptr, op int, db * /*line :75:55*/_Ctype_char /*line :75:61*/, table * /*line :75:70*/_Ctype_char /*line :75:76*/, rowid int64) {
	callback := lookupHandle(handle).(func(int, string, string, int64))
	callback(op, ( /*line :77:15*/_Cfunc_GoString /*line :77:24*/)(db), ( /*line :77:31*/_Cfunc_GoString /*line :77:40*/)(table), rowid)
}

//export authorizerTrampoline
func authorizerTrampoline(handle uintptr, op int, arg1 * /*line :81:57*/_Ctype_char /*line :81:63*/, arg2 * /*line :81:71*/_Ctype_char /*line :81:77*/, arg3 * /*line :81:85*/_Ctype_char /*line :81:91*/) int {
	callback := lookupHandle(handle).(func(int, string, string, string) int)
	return callback(op, ( /*line :83:22*/_Cfunc_GoString /*line :83:31*/)(arg1), ( /*line :83:40*/_Cfunc_GoString /*line :83:49*/)(arg2), ( /*line :83:58*/_Cfunc_GoString /*line :83:67*/)(arg3))
}

//export preUpdateHookTrampoline
func preUpdateHookTrampoline(handle uintptr, dbHandle uintptr, op int, db * /*line :87:76*/_Ctype_char /*line :87:82*/, table * /*line :87:91*/_Ctype_char /*line :87:97*/, oldrowid int64, newrowid int64) {
	hval := lookupHandleVal(handle)
	data := SQLitePreUpdateData{
		Conn:         hval.db,
		Op:           op,
		DatabaseName: ( /*line :92:17*/_Cfunc_GoString /*line :92:26*/)(db),
		TableName:    ( /*line :93:17*/_Cfunc_GoString /*line :93:26*/)(table),
		OldRowID:     oldrowid,
		NewRowID:     newrowid,
	}
	callback := hval.val.(func(SQLitePreUpdateData))
	callback(data)
}

// Use handles to avoid passing Go pointers to C.
type handleVal struct {
	db  *SQLiteConn
	val interface{}
}

var handleLock sync.Mutex
var handleVals = make(map[uintptr]handleVal)
var handleIndex uintptr = 100

func newHandle(db *SQLiteConn, v interface{}) uintptr {
	handleLock.Lock()
	defer handleLock.Unlock()
	i := handleIndex
	handleIndex++
	handleVals[i] = handleVal{db, v}
	return i
}

func lookupHandleVal(handle uintptr) handleVal {
	handleLock.Lock()
	defer handleLock.Unlock()
	r, ok := handleVals[handle]
	if !ok {
		if handle >= 100 && handle < handleIndex {
			panic("deleted handle")
		} else {
			panic("invalid handle")
		}
	}
	return r
}

func lookupHandle(handle uintptr) interface{} {
	return lookupHandleVal(handle).val
}

func deleteHandles(db *SQLiteConn) {
	handleLock.Lock()
	defer handleLock.Unlock()
	for handle, val := range handleVals {
		if val.db == db {
			delete(handleVals, handle)
		}
	}
}

// This is only here so that tests can refer to it.
type callbackArgRaw  /*line :149:21*/_Ctype_struct_sqlite3_value /*line :149:36*/

type callbackArgConverter func(* /*line :151:33*/_Ctype_struct_sqlite3_value /*line :151:48*/) (reflect.Value, error)

type callbackArgCast struct {
	f   callbackArgConverter
	typ reflect.Type
}

func (c callbackArgCast) Run(v * /*line :158:33*/_Ctype_struct_sqlite3_value /*line :158:48*/) (reflect.Value, error) {
	val, err := c.f(v)
	if err != nil {
		return reflect.Value{}, err
	}
	if !val.Type().ConvertibleTo(c.typ) {
		return reflect.Value{}, fmt.Errorf("cannot convert %s to %s", val.Type(), c.typ)
	}
	return val.Convert(c.typ), nil
}

func callbackArgInt64(v * /*line :169:26*/_Ctype_struct_sqlite3_value /*line :169:41*/) (reflect.Value, error) {
	if func() _Ctype_int{ _cgo0 := /*line :170:26*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_type(_cgo0); }() != ( /*line :170:32*/_Ciconst_SQLITE_INTEGER /*line :170:47*/) {
		return reflect.Value{}, fmt.Errorf("argument must be an INTEGER")
	}
	return reflect.ValueOf(int64(func() _Ctype_sqlite3_int64{ _cgo0 := /*line :173:53*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_int64(_cgo0); }())), nil
}

func callbackArgBool(v * /*line :176:25*/_Ctype_struct_sqlite3_value /*line :176:40*/) (reflect.Value, error) {
	if func() _Ctype_int{ _cgo0 := /*line :177:26*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_type(_cgo0); }() != ( /*line :177:32*/_Ciconst_SQLITE_INTEGER /*line :177:47*/) {
		return reflect.Value{}, fmt.Errorf("argument must be an INTEGER")
	}
	i := int64(func() _Ctype_sqlite3_int64{ _cgo0 := /*line :180:35*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_int64(_cgo0); }())
	val := false
	if i != 0 {
		val = true
	}
	return reflect.ValueOf(val), nil
}

func callbackArgFloat64(v * /*line :188:28*/_Ctype_struct_sqlite3_value /*line :188:43*/) (reflect.Value, error) {
	if func() _Ctype_int{ _cgo0 := /*line :189:26*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_type(_cgo0); }() != ( /*line :189:32*/_Ciconst_SQLITE_FLOAT /*line :189:45*/) {
		return reflect.Value{}, fmt.Errorf("argument must be a FLOAT")
	}
	return reflect.ValueOf(float64(func() _Ctype_double{ _cgo0 := /*line :192:56*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_double(_cgo0); }())), nil
}

func callbackArgBytes(v * /*line :195:26*/_Ctype_struct_sqlite3_value /*line :195:41*/) (reflect.Value, error) {
	switch func() _Ctype_int{ _cgo0 := /*line :196:30*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_type(_cgo0); }() {
	case ( /*line :197:7*/_Ciconst_SQLITE_BLOB /*line :197:19*/):
		l := func() _Ctype_int{ _cgo0 := /*line :198:30*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_bytes(_cgo0); }()
		p := func() _cgo_unsafe.Pointer{ _cgo0 := /*line :199:29*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_blob(_cgo0); }()
		return reflect.ValueOf(func() []byte{ _cgo0 := /*line :200:36*/p; var _cgo1 _Ctype_int = /*line :200:39*/l; _cgoCheckPointer(_cgo0); return _Cfunc_GoBytes(_cgo0, _cgo1); }()), nil
	case ( /*line :201:7*/_Ciconst_SQLITE_TEXT /*line :201:19*/):
		l := func() _Ctype_int{ _cgo0 := /*line :202:30*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_bytes(_cgo0); }()
		c := unsafe.Pointer(func() *_Ctype_uchar{ _cgo0 := /*line :203:44*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_text(_cgo0); }())
		return reflect.ValueOf(func() []byte{ _cgo0 := /*line :204:36*/c; var _cgo1 _Ctype_int = /*line :204:39*/l; _cgoCheckPointer(_cgo0); return _Cfunc_GoBytes(_cgo0, _cgo1); }()), nil
	default:
		return reflect.Value{}, fmt.Errorf("argument must be BLOB or TEXT")
	}
}

func callbackArgString(v * /*line :210:27*/_Ctype_struct_sqlite3_value /*line :210:42*/) (reflect.Value, error) {
	switch func() _Ctype_int{ _cgo0 := /*line :211:30*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_type(_cgo0); }() {
	case ( /*line :212:7*/_Ciconst_SQLITE_BLOB /*line :212:19*/):
		l := func() _Ctype_int{ _cgo0 := /*line :213:30*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_bytes(_cgo0); }()
		p := (* /*line :214:10*/_Ctype_char /*line :214:16*/)(func() _cgo_unsafe.Pointer{ _cgo0 := /*line :214:39*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_blob(_cgo0); }())
		return reflect.ValueOf(( /*line :215:26*/_Cfunc_GoStringN /*line :215:36*/)(p, l)), nil
	case ( /*line :216:7*/_Ciconst_SQLITE_TEXT /*line :216:19*/):
		c := (* /*line :217:10*/_Ctype_char /*line :217:16*/)(unsafe.Pointer(func() *_Ctype_uchar{ _cgo0 := /*line :217:54*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_text(_cgo0); }()))
		return reflect.ValueOf(( /*line :218:26*/_Cfunc_GoString /*line :218:35*/)(c)), nil
	default:
		return reflect.Value{}, fmt.Errorf("argument must be BLOB or TEXT")
	}
}

func callbackArgGeneric(v * /*line :224:28*/_Ctype_struct_sqlite3_value /*line :224:43*/) (reflect.Value, error) {
	switch func() _Ctype_int{ _cgo0 := /*line :225:30*/v; _cgoCheckPointer(_cgo0); return _Cfunc_sqlite3_value_type(_cgo0); }() {
	case ( /*line :226:7*/_Ciconst_SQLITE_INTEGER /*line :226:22*/):
		return callbackArgInt64(v)
	case ( /*line :228:7*/_Ciconst_SQLITE_FLOAT /*line :228:20*/):
		return callbackArgFloat64(v)
	case ( /*line :230:7*/_Ciconst_SQLITE_TEXT /*line :230:19*/):
		return callbackArgString(v)
	case ( /*line :232:7*/_Ciconst_SQLITE_BLOB /*line :232:19*/):
		return callbackArgBytes(v)
	case ( /*line :234:7*/_Ciconst_SQLITE_NULL /*line :234:19*/):
		// Interpret NULL as a nil byte slice.
		var ret []byte
		return reflect.ValueOf(ret), nil
	default:
		panic("unreachable")
	}
}

func callbackArg(typ reflect.Type) (callbackArgConverter, error) {
	switch typ.Kind() {
	case reflect.Interface:
		if typ.NumMethod() != 0 {
			return nil, errors.New("the only supported interface type is interface{}")
		}
		return callbackArgGeneric, nil
	case reflect.Slice:
		if typ.Elem().Kind() != reflect.Uint8 {
			return nil, errors.New("the only supported slice type is []byte")
		}
		return callbackArgBytes, nil
	case reflect.String:
		return callbackArgString, nil
	case reflect.Bool:
		return callbackArgBool, nil
	case reflect.Int64:
		return callbackArgInt64, nil
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:
		c := callbackArgCast{callbackArgInt64, typ}
		return c.Run, nil
	case reflect.Float64:
		return callbackArgFloat64, nil
	case reflect.Float32:
		c := callbackArgCast{callbackArgFloat64, typ}
		return c.Run, nil
	default:
		return nil, fmt.Errorf("don't know how to convert to %s", typ)
	}
}

func callbackConvertArgs(argv []* /*line :274:34*/_Ctype_struct_sqlite3_value /*line :274:49*/, converters []callbackArgConverter, variadic callbackArgConverter) ([]reflect.Value, error) {
	var args []reflect.Value

	if len(argv) < len(converters) {
		return nil, fmt.Errorf("function requires at least %d arguments", len(converters))
	}

	for i, arg := range argv[:len(converters)] {
		v, err := converters[i](arg)
		if err != nil {
			return nil, err
		}
		args = append(args, v)
	}

	if variadic != nil {
		for _, arg := range argv[len(converters):] {
			v, err := variadic(arg)
			if err != nil {
				return nil, err
			}
			args = append(args, v)
		}
	}
	return args, nil
}

type callbackRetConverter func(* /*line :301:33*/_Ctype_struct_sqlite3_context /*line :301:50*/, reflect.Value) error

func callbackRetInteger(ctx * /*line :303:30*/_Ctype_struct_sqlite3_context /*line :303:47*/, v reflect.Value) error {
	switch v.Type().Kind() {
	case reflect.Int64:
	case reflect.Int8, reflect.Int16, reflect.Int32, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:
		v = v.Convert(reflect.TypeOf(int64(0)))
	case reflect.Bool:
		b := v.Interface().(bool)
		if b {
			v = reflect.ValueOf(int64(1))
		} else {
			v = reflect.ValueOf(int64(0))
		}
	default:
		return fmt.Errorf("cannot convert %s to INTEGER", v.Type())
	}

	func() { _cgo0 := /*line :319:25*/ctx; var _cgo1 _Ctype_sqlite3_int64 = _Ctype_sqlite3_int64(v.Interface().(int64)); _cgoCheckPointer(_cgo0); _Cfunc_sqlite3_result_int64(_cgo0, _cgo1); }()
	return nil
}

func callbackRetFloat(ctx * /*line :323:28*/_Ctype_struct_sqlite3_context /*line :323:45*/, v reflect.Value) error {
	switch v.Type().Kind() {
	case reflect.Float64:
	case reflect.Float32:
		v = v.Convert(reflect.TypeOf(float64(0)))
	default:
		return fmt.Errorf("cannot convert %s to FLOAT", v.Type())
	}

	func() { _cgo0 := /*line :332:26*/ctx; var _cgo1 _Ctype_double = _Ctype_double(v.Interface().(float64)); _cgoCheckPointer(_cgo0); _Cfunc_sqlite3_result_double(_cgo0, _cgo1); }()
	return nil
}

func callbackRetBlob(ctx * /*line :336:27*/_Ctype_struct_sqlite3_context /*line :336:44*/, v reflect.Value) error {
	if v.Type().Kind() != reflect.Slice || v.Type().Elem().Kind() != reflect.Uint8 {
		return fmt.Errorf("cannot convert %s to BLOB", v.Type())
	}
	i := v.Interface()
	if i == nil || len(i.([]byte)) == 0 {
		func() { _cgo0 := /*line :342:25*/ctx; _cgoCheckPointer(_cgo0); _Cfunc_sqlite3_result_null(_cgo0); }()
	} else {
		bs := i.([]byte)
		func() { _cgo0 := /*line :345:26*/ctx; _cgoIndex1 := &/*line :345:47*/bs; _cgo1 := /*line :345:31*/unsafe.Pointer(&(*_cgoIndex1)[0]); var _cgo2 _Ctype_int = _Ctype_int(len(bs)); _cgoCheckPointer(_cgo0); _cgoCheckPointer(_cgo1, *_cgoIndex1); _Cfunc__sqlite3_result_blob(_cgo0, _cgo1, _cgo2); }()
	}
	return nil
}

func callbackRetText(ctx * /*line :350:27*/_Ctype_struct_sqlite3_context /*line :350:44*/, v reflect.Value) error {
	if v.Type().Kind() != reflect.String {
		return fmt.Errorf("cannot convert %s to TEXT", v.Type())
	}
	func() { _cgo0 := /*line :354:25*/ctx; var _cgo1 *_Ctype_char = _Cfunc_CString(v.Interface().(string)); _cgoCheckPointer(_cgo0); _Cfunc__sqlite3_result_text(_cgo0, _cgo1); }()
	return nil
}

func callbackRetNil(ctx * /*line :358:26*/_Ctype_struct_sqlite3_context /*line :358:43*/, v reflect.Value) error {
	return nil
}

func callbackRet(typ reflect.Type) (callbackRetConverter, error) {
	switch typ.Kind() {
	case reflect.Interface:
		errorInterface := reflect.TypeOf((*error)(nil)).Elem()
		if typ.Implements(errorInterface) {
			return callbackRetNil, nil
		}
		fallthrough
	case reflect.Slice:
		if typ.Elem().Kind() != reflect.Uint8 {
			return nil, errors.New("the only supported slice type is []byte")
		}
		return callbackRetBlob, nil
	case reflect.String:
		return callbackRetText, nil
	case reflect.Bool, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Int, reflect.Uint:
		return callbackRetInteger, nil
	case reflect.Float32, reflect.Float64:
		return callbackRetFloat, nil
	default:
		return nil, fmt.Errorf("don't know how to convert to %s", typ)
	}
}

func callbackError(ctx * /*line :386:25*/_Ctype_struct_sqlite3_context /*line :386:42*/, err error) {
	cstr := ( /*line :387:10*/_Cfunc_CString /*line :387:18*/)(err.Error())
	defer func() func() { _cgo0 := /*line :388:15*/unsafe.Pointer(cstr); return func() { _cgoCheckPointer(_cgo0); _Cfunc_free(_cgo0); }}()()
	func() { _cgo0 := /*line :389:25*/ctx; var _cgo1 *_Ctype_char = /*line :389:30*/cstr; var _cgo2 _Ctype_int = _Ctype_int(-1); _cgoCheckPointer(_cgo0); _Cfunc_sqlite3_result_error(_cgo0, _cgo1, _cgo2); }()
}

// Test support code. Tests are not allowed to import "C", so we can't
// declare any functions that use C.sqlite3_value.
func callbackSyntheticForTests(v reflect.Value, err error) callbackArgConverter {
	return func(* /*line :395:15*/_Ctype_struct_sqlite3_value /*line :395:30*/) (reflect.Value, error) {
		return v, err
	}
}
